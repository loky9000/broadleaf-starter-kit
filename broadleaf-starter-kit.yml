# Broadleaf Starter Kit
application:
# Input Configuration parameters.
# In this section you can set input configuration parameters which you
# will be able to change later in reconfiguration
  configuration:
    configuration.scm-uri: "git://github.com/qubell-bazaar/DemoSite.git" # Broadleaf DemoSite sources url
    configuration.scm-branch: solr-cloud # solr-green (Branch name in your fork)
    configuration.clusterSize: 1 # Numbers of hosts with application for "Application Server" Component
    configuration.SolrclusterSize: 0
    configuration.solr-collections: ["https://raw.github.com/qubell-bazaar/DemoSite/solr-cloud/core/src/main/resources/cores/cores.tar.gz"] # Archive with cores for "Solr Cloud" component
    configuration.solr-version: "4.4.0" # Solr Version
    configuration.recipe-url: "https://s3.amazonaws.com/qubell-starter-kit-artifacts/qubell-bazaar/broadleaf-starter-kit-cookbooks-stable-b129bf8.tar.gz" # Chef Cookbooks Url
    compute-app.hardwareId: "c1.medium"
    compute-app.imageId: "ami-246ed34c" # image  for Compute instanse
    compute-app.login: "ec2-user" # identity Compute instance.
    compute-app.locationId: "us-east-1"
    compute.imageId: "ami-246ed34c" # image  for Compute instanse
    compute.login: "ec2-user" # identity Compute instance.
    compute.locationId: "us-east-1"
    compute.hardwareId: "m1.small" ###EC2  Instance type
# Binding section.
# Here we bind main.workflow component on submodules.
# This is a component binding section it mean interfaces in components [main.workflow, app]
# will be connected by pin names regardless of interface name

  bindings:
    - [ClusterHarvester, AppCluster.AppServer]
    - [SolrClusterHarvester, SolrCluster.Solr]
    - [AppDeployer, Database]
    - [AppDeployer, SolrClusterHarvester]
    - [LoadBalancer, AppCluster.AppServer]
    - [AppDeployer, BuildServer]
    - [AppDeployer#result, AppCluster.AppServer#source]
    - [AppDeployer#result, AppCluster.AppServer#update-indicator]

# Application Interfaces binding section.
# Here we describe a interfaces with pins and their bindings on component's interfaces.
# For binding using function bind(Component1#interface.pin, Component2#interface.pin)
  interfaces:
    configuration: # Contain pins with type: configuration()
      scm-uri: "bind(BuildServer#configuration.scm-uri)"
      scm-branch: "bind(BuildServer#configuration.scm-branch)"
      clusterSize: "bind(AppCluster#configuration.quantity, ClusterHarvester#input.clusterSize)"
      SolrclusterSize: "bind(SolrCluster#configuration.quantity, SolrClusterHarvester#input.clusterSize)"
      solr-collections: "bind(SolrCluster.Solr#configuration.solr-collections)"
      solr-version: "bind(SolrCluster.Solr#configuration.solr-version)"
      recipe-url: "bind(AppDeployer#input.recipe-url)"
    compute:
      "*": "bind(Database#compute.*, LoadBalancer#compute.*)"
    compute-app:
      "*": "bind(AppCluster.AppServer#compute-config.*)"
    app-meta:
      application-pic: "bind(metadata#output.application-pic)"
    broadleaf:  # That values we want to see on main application dashboard
      DB:       "bind(Database#database.dbms)"
      BroadleafUrls: "bind(LoadBalancer#haproxy.entry-urls)"
      Application_hosts: "bind(ClusterHarvester#result.app-hosts)"
      Solr-urls: "bind(SolrClusterHarvester#result.solr-urls)"
      zoo-ui: "bind(SolrClusterHarvester#result.zoo-ui)"

## Components definitions ##

  components:
    metadata:
      type: cobalt.common.Constants
      interfaces:
        output:
          application-pic:
            type: publish-signal(map<string, object>)
            name: ""
      configuration:
        configuration.values:
          output.application-pic:
            large: "https://s3.amazonaws.com/qubell-images/broadleaf.png"
            small: "https://s3.amazonaws.com/qubell-images/broadleaf.png"
            small-height: 100

    SolrClusterHarvester:
      type: workflow.Instance
      interfaces:
        input:
          clusterSize: 
            type: configuration(int)
            suggestions:
              disable: 0
              enable:  1
        solr:
          solr-urls:
            type: consume-signal(list<string>)
            name: Solr API
          solr-zoo-nodes:
            type: consume-signal(list<string>)
            name: Zookeeper hosts (private)
          zoo-ui:
            type: consume-signal(list<string>)
            name: Exhibitors UI
        result:
          solr-urls:
            type: publish-signal(list<string>)
            name: Solr API
          solr-zoo-nodes:
            type: publish-signal(list<string>)
            name: Zookeeper hosts (private)
          zoo-ui:
            type: publish-signal(list<string>)
            name: Exhibitors UI
      configuration:
        configuration.triggers:
          input.clusterSize: update
        configuration.propagateStatus: [ update ]
        configuration.workflows:
          update: &update
            steps:
              - waitPeers:
                   action: waitPeers
                   parameters:
                     interfaces:
                       solr: "{$.clusterSize}"
                     timeout:
                       30 minute
              - get-signals:
                  action: getSignals
                  precedingPhases: [ waitPeers ]
                  parameters:
                    multi: true
                  output:
                    signals: result
            return:
              solr-urls:     { value: "{$.signals.solr.*.solr-urls}"}
              solr-zoo-nodes:     { value: "{$.signals.solr.*.solr-zoo-nodes}"}
              zoo-ui:     { value: "{$.signals.solr.*.zoo-ui}"}
          launch: *update        
            
    ClusterHarvester:
      type: workflow.Instance
      interfaces:
        input:
          clusterSize: configuration(int)
        tomcat:
          app-host:
             type: consume-signal(string)
             name: Solr host
        result:
          app-hosts: publish-signal(list<string>)
      configuration:
        configuration.triggers:
          input.clusterSize: update
        configuration.propagateStatus: [ update ]
        configuration.workflows:
          update: &update
            steps:
              - waitPeers:
                   action: waitPeers
                   parameters:
                     interfaces:
                       tomcat: "{$.clusterSize}"
                     timeout:
                       30 minute
              - get-signals:
                  action: getSignals
                  precedingPhases: [ waitPeers ]
                  parameters:
                    multi: true
                  output:
                    signals: result
            return:
              app-hosts:     { value: "{$.signals.tomcat.*.app-host}"}
          launch: *update

    AppDeployer:  # We have a root component called "main"
      type: workflow.Instance # It's a component type to run imperative workflow
      interfaces: # Each component have interfaces wit pins
        input:
          recipe-url: 
            type: configuration(string)
          db-sql-url:
            type: configuration(list<string>)
          db-user:
            type: configuration(string)
          db-password:
            type: configuration(string)
          privileges:
            type: configuration(list<string>)
        db:
          dbms:    consume-signal(object)
          db-host: consume-signal(string)
          db-port: consume-signal(int)
          schema:
            type: send-command(string db-user, string db-user-password, list<string> db-user-privileges => object connection)
          file-query:
             type: send-command(object connection, list<string> sql-url)
        build-result:
          war_urls: consume-signal(list<string>)
        compute-maven:
          networks:   consume-signal(map<string, map<string, string>>)
          exec:       send-command(string command, int timeout => string stdOut, string stdErr => string stdOut, string stdErr, int exitCode)
          put-file:   send-command(string filename, bytes payload)
          get-file:   send-command(string filename => bytes payload)
        solr-zoo: # Signals which we send/receive to Solr submodule
          solr-zoo-nodes:
             type: consume-signal(list<string>)
             name: Zookeeper hosts
          zoo-ui:
             type: consume-signal(list<string>)
             name: Zookeeper UI
          solr-urls:
             type: consume-signal(list<string>)
             name: Solr API
        result:
          war-update:      publish-signal(string)
          uri:           publish-signal(list<string>)
          path:          publish-signal(list<string>)
          lib-uri:       publish-signal(list<string>)
          context-nodes: publish-signal(object)
          context-attrs: publish-signal(object)
          java-opts:     publish-signal(string)
      required: [db, solr-zoo,build-result] # We don't continue without signals on required interfaces. In this case we are waiting tomcat, mysql and solr+zookeeper hosts return values
       # Static constants #
      configuration: 
        input.db-sql-url: ["https://raw.github.com/qubell-bazaar/DemoSite/solr-cloud/core/src/main/resources/sql/schema.sql", "https://raw.github.com/qubell-bazaar/DemoSite/solr-cloud/core/src/main/resources/sql/load_full.sql"]
        input.db-user: broadleaf #const
        input.db-password: broadleaf #const
        input.privileges: ["all"] #const
        configuration.triggers:
          build-result.war_urls: update
          solr-zoo.solr-urls: update
        configuration.propagateStatus: [ update ] # Change application state to "Executing" when relevant workflows are running 
        configuration.workflows:
          update: &update
            steps:
              - get-signals:
                  action: getSignals
                  output:
                    signals: result
              - manage-schema:
                  action: db.schema
                  precedingPhases: [ get-signals ]
                  parameters:
                    commandCallTimeout: 10 minutes
                    db-user: "{$.db-user}"
                    db-user-password: "{$.db-password}"
                    db-user-privileges: "{$.privileges}"
                  output:
                    con: connection
              - upload-sql:
                  action: db.file-query
                  precedingPhases: [ manage-schema ]
                  parameters:
                    commandCallTimeout: 10 minutes
                    connection: "{$.con}"
                    sql-url: "{$.db-sql-url}"
              - add-solr-support: # add external Solr support instead embeded
                  action: "chefrun"
                  phase: add-solr-support
                  precedingPhases: [ upload-sql ]
                  parameters:
                      isSolo: true
                      roles: [ compute-maven ]
                      runList: [ "recipe[cookbook-qubell-broadleaf::add-solr-support]" ]
                      recipeUrl: "{$.recipe-url}"
                      jattrs:
                        cookbook-qubell-broadleaf:
                          solr_url: "{$.signals.solr-zoo.solr-zoo-nodes}"
                          solr_reindex_url: "{$.signals.solr-zoo.solr-zoo-nodes}"
                  output:
                      chefAttrs: chefState
              
            return: # We want to see DemoSite and AdminPanel urls will be present on application dashboard
              war-update:      { value: "{$.chefAttrs['*'][0]['cookbook-qubell-broadleaf']['updated']}" }
              uri: { value: "{$.signals.build-result.war_urls}" }
              path: { value: ["/admin", "/"] }
              lib-uri: { value: ["http://repo1.maven.org/maven2/org/apache/tomcat/dbcp/6.0.26/dbcp-6.0.26.jar", "http://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.6/mysql-connector-java-5.1.6.jar"] }
              context-attrs: { value: {} }
              context-nodes: { value: [] }
              java-opts: { value: "-Djava.awt.headless=true -Xms128m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:+UseConcMarkSweepGC -Ddatabase.driver=com.mysql.jdbc.Driver -Ddatabase.url=jdbc:mysql://{$.signals.db.db-host}:{$.signals.db.db-port}/{$.db-user}?autoReconnect=true -Ddatabase.user={$.db-user} -Ddatabase.password={$.db-password}" }
          launch: *update
#Submodules Definition
    Database:
      type: reference.Submodule
      configuration:
        __locator.application-id: "Database"
      interfaces:
        compute: &compute
          imageId:         configuration(string)
          hardwareId:      configuration(string)
          locationId:      configuration(string)
          login:           configuration(string)
        database:
          dbms:
             type: publish-signal(object)
             name: Database parameters
          #for ui only
          db-port:
             type: publish-signal(int)
             name: Database port
          db-host:
             type: publish-signal(string)
             name: Database host
          schema:
             type: receive-command(string db-user, string db-user-password, list<string> db-user-privileges => object connection)
             name: Manage schema
          file-query:
             type: receive-command(object connection, list<string> sql-url)
             name: Run a SQL query
        configuration:
          db-port:            { type: configuration(int),          name: Database listen port     }
          db-root-password:   { type: configuration(string),       name: Database root password   }
          recipe-url:         { type: configuration(string),       name: Cookbooks url            }
    LoadBalancer:
      type: reference.Submodule
      configuration:
        __locator.application-id: "Load Balancer"
      interfaces:
        compute: *compute
        servers:
          app-uri: consume-signal(list<string>)
        haproxy:
          stats-url: { type: publish-signal(string), name: Haproxy statistics }
          entry-urls: { type: publish-signal(list<string>), name: Entry urls         }
    BuildServer:
      type: reference.Submodule
      configuration:
        __locator.application-id: "Builder"
      interfaces:
        compute-config: *compute
        compute:
          networks:       publish-signal(map<string, map<string, string>>)
          exec:           receive-command(string command, int timeout => string stdOut, string stdErr => string stdOut, string stdErr, int exitCode)
          put-file:       receive-command(string filename, bytes payload)
          get-file:       receive-command(string filename => bytes payload)
        configuration:
          scm-uri:      configuration(string)
          scm-branch:   configuration(string)
        build-result:
          war_urls: publish-signal(list<string>)
    AppCluster:
      type: composite.Scaler
      components:
        AppServer:
          type: reference.Submodule
          configuration:
            __locator.application-id: "Application Server"
          interfaces:
            update-indicator:
              war-update:    consume-signal(string)
            source:
              java-opts:     consume-signal(string)
              uri:           consume-signal(list<string>)
              path:          consume-signal(list<string>)
              lib-uri:       consume-signal(list<string>)
              context-nodes: consume-signal(object)
              context-attrs: consume-signal(object)
            compute-config: *compute
            compute:
              networks:       publish-signal(map<string, map<string, string>>)
              exec:           receive-command(string command, int timeout => string stdOut, string stdErr => string stdOut, string stdErr, int exitCode)
              put-file:       receive-command(string filename, bytes payload)
              get-file:       receive-command(string filename => bytes payload)
            tomcat:
              app-host: publish-signal(string)
              app-uri: publish-signal(list<string>)
            configuration:
              app-port:     { type: configuration(int),          name: Tomcat listen port }
              java-opts:    { type: configuration(string),       name: JAVA_OPTS          }
              recipe-url:   { type: configuration(string),       name: Cookbooks url      }

    SolrCluster:
      type: composite.Scaler
      configuration:
        configuration.minQuantity: 0
        configuration.maxQuantity: 1
      components:
        Solr:
          type: reference.Submodule
          configuration:
             __locator.application-id: "Solr Cloud"
          interfaces:
            configuration:
              solr-version:
                  type: configuration(string)
                  name: Solr version
              solr-collections:
                  type: configuration(list<string>)
                  name: Solr collections
            solr-zoo:
              solr-urls:
                  type: publish-signal(list<string>)
                  name: Solr API
              solr-zoo-nodes:
                  type: publish-signal(list<string>)
                  name: Zookeeper hosts (private)
              zoo-ui:
                  type: publish-signal(list<string>)
                  name: Exhibitors UI
